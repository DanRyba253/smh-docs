{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"smh A string manipulation tool written in haskell. smh aims to bring the power of optics into the command line. It provides a terse, domain specific language for various string manipulation tasks. Getting Started User Guide Examples of usage smh 'words.if len>3|get' < input_file - display all words longer than 3 characters smh 'words.[0]|over upper' \"hello world\" - capitalize all words smh 'lines.if startsWith \"*\".<words>.[2]|get' < input_file - display the third word in lines that start with an asterisk Visit the getting started page or the user guide for more details and examples.","title":"Home"},{"location":"contributing/","text":"Contributing Contribute to this project via forking the GitHub repo or submitting an issue to the issue tracker . Contributing guidelines Focusers are implemented as optics , if you're no familiar with them and the lens library. Get a feel for them, before contributing code. Focuser implementations live in src/Focusers.hs Mapping implementations live in src/Mappings.hs Focuser and mapping parsers live in src/Parsers.hs Action implementations and their parsers live in src/Actions.hs Mappings should return the same kind of focus they were given. i.e. if you give them a String focus, they should return a String focus. Updatable focusers should reconstruct the same kind of focus that they deconstructed.","title":"Contributing"},{"location":"contributing/#_1","text":"","title":""},{"location":"contributing/#contributing","text":"Contribute to this project via forking the GitHub repo or submitting an issue to the issue tracker .","title":"Contributing"},{"location":"contributing/#contributing-guidelines","text":"Focusers are implemented as optics , if you're no familiar with them and the lens library. Get a feel for them, before contributing code. Focuser implementations live in src/Focusers.hs Mapping implementations live in src/Mappings.hs Focuser and mapping parsers live in src/Parsers.hs Action implementations and their parsers live in src/Actions.hs Mappings should return the same kind of focus they were given. i.e. if you give them a String focus, they should return a String focus. Updatable focusers should reconstruct the same kind of focus that they deconstructed.","title":"Contributing guidelines"},{"location":"getting-started/","text":"Installation To install smh download the latest release from GitHub . Building Prerequisites Have cabal and ghc installed. For more details visit cabal documentation . Building steps git clone https://github.com/DanRyba253/smh - clone the repo cd smh - navigate into the repo cabal install --install-dir=. --install-method=copy - install smh into the current directory mv smh <your-bin-dir> - move smh binary to your prefered binary directory What's next? Visit the user guide for the usage tutorial and examples.","title":"Getting started"},{"location":"getting-started/#_1","text":"","title":""},{"location":"getting-started/#installation","text":"To install smh download the latest release from GitHub .","title":"Installation"},{"location":"getting-started/#building","text":"","title":"Building"},{"location":"getting-started/#prerequisites","text":"Have cabal and ghc installed. For more details visit cabal documentation .","title":"Prerequisites"},{"location":"getting-started/#building-steps","text":"git clone https://github.com/DanRyba253/smh - clone the repo cd smh - navigate into the repo cabal install --install-dir=. --install-method=copy - install smh into the current directory mv smh <your-bin-dir> - move smh binary to your prefered binary directory","title":"Building steps"},{"location":"getting-started/#whats-next","text":"Visit the user guide for the usage tutorial and examples.","title":"What's next?"},{"location":"license/","text":"Copyright (c) 2024 dani-rybe Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"release-notes/","text":"v0.1.0 No release notes for now, this is the first version :) v0.1.1 Changed mapping separator from \">\" to \":\"","title":"Release notes"},{"location":"release-notes/#_1","text":"","title":""},{"location":"release-notes/#v010","text":"No release notes for now, this is the first version :)","title":"v0.1.0"},{"location":"release-notes/#v011","text":"Changed mapping separator from \">\" to \":\"","title":"v0.1.1"},{"location":"user-guide/","text":"Overview Here's the core syntax of smh: smh <command> [input] <command> is a string specifiyng what smh should do with the input string. If the input string is not given, smh gets input from stdin. <command> string The command string consists of two parts, separated by the pipe symbol \"|\"\" The first part is a list of focusers, separated by the dot symbol \".\" The second part is an action. The idea is that we use focusers to nail down on the part of the string that we want to access, and then the action that we want to perform on it. For example: smh 'words|get' \"hello world\" - 'words' focuser focuses on all words within the string, the get action prints them to the screen. How do focusers work? Each focuser in the focuser list can be thought of as a function that takes in a focus and returns a list of new focuses. Each focuser represents a focusing step. During each step, every active focus gets fed into the current focuser and all the new focuses that are produces go to the next step. What is a focus? Focuses can be devided into two groups: Updatable focuses - represent some part of the input string, these can be updated through actions, to get an updated input string. Non-updatable focuses - these represent read-only data, obtained from the input string, and thus can't be updated, only read. Focuses are further divided into two types: Strings - represent string data. Lists - represent lists of sub-focuses. For example the \"words\" focuser takes in a String focus and produces Updatable String focuses for each word in it. At the very start we have one active Updatable String focus which represents the whole input string. For the description of available focusers visit Focuser documentation What is an action? Action is the part of the command string that goes after the pipe symbol. Actions can be used to display parts of input, or change them. For the description of available actions visit Action documentation Focuser documentation id (focuser) \"id\" is the simplest focuser possible, it returns the same focus that was given to it. It can be useful if you want to focus on the whole input string. $ smh 'id|get' \"hello world\" hello world each \"each\" focuses on each element of a List , or every character in a String . $ smh 'each|get' \"hello\" h e l l o words \"words\" focuses on each word within a String . $ smh 'words|get' \"hello world\" hello world lines \"lines\" focuses on every line within the input string. $ printf \"hello\\nworld\" | smh 'lines|get' hello world ws \"ws\" focuses on consequetive strings of whitespace characters. $ smh '<ws>.len|get' \"a b c d e\" 4 cols \"cols\" focuses on every column within the input string. Columns are represented as Lists of words. $ smh '<cols>.[0]|get' \"hello my\\nname is Dani\" hello name slice (focuser) \"slice\" ({}) focuses on a part of a String or a List , using a python-like syntax. $ smh '{1:3}|get' \"hello\" el $ smh '{2:}|get' \"hello\" llo $ smh '{:-2}|get' \"hello\" hel $ smh '{:2,3:}|get' \"hello\" helo index ([n]) \"index\" focuses on the nth element of a List or a String . $ smh '[1]|get' \"hello\" e sortedLexBy \"sortedLexBy\" focuses on the lexicographically sorted version of a List or a String , using another focuser as a key. $ mh 'sortedLexBy id|get' \"hello\" ehllo Note: \"sortedLexBy\" parses the next focuser non-greedily , i.e. \"sortedLexBy focuser1.focuser2 == (sortedLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"sortedLexBy (focuser1.focuser2)\" sortedLex A shorthand for \"sortedLexBy id\" minLexBy \"minLexBy\" focuses on the lexicographically smallest element in a List or a String , using another focuser as a key. $ smh '<words>.minLexBy id|get' \"hello my name is Dani\" Dani Note: \"minLexBy\" parses the next focuser non-greedily , i.e. \"minLexBy focuser1.focuser2 == (minLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"minLexBy (focuser1.focuser2)\" maxLexBy \"maxLexBy\" focuses on the lexicographically largest element in a List or a String , using another focuser as a key. $ smh '<words>.maxLexBy id|get' \"hello my name is Dani\" name Note: \"maxLexBy\" parses the next focuser non-greedily , i.e. \"maxLexBy focuser1.focuser2 == (maxLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxLexBy (focuser1.focuser2)\" minLex A shorthand for \"minLexBy id\" maxLex A shorthand for \"maxLexBy id\" sortedBy \"sortedBy\" focuses on the sorted version of a List or a String , using another focuser as a key. $ smh '<words>.sortedBy len|get' \"hello my name is Dani\" my is name Dani hello Note: \"sortedBy\" parses the next focuser non-greedily , i.e. \"sortedBy focuser1.focuser2 == (sortedBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"sortedBy (focuser1.focuser2)\" Note: \"sortedBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted. sorted A shorthand for \"sortedBy id\" minBy \"minBy\" focuses on the first smallest element in a List or a String , using another focuser as a key. $ smh '<words>.minBy len|get' \"Hello my name is Dani\" my Note: \"minBy\" parses the next focuser non-greedily , i.e. \"minBy focuser1.focuser2 == (minBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"minBy (focuser1.focuser2)\" Note: \"minBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted. maxBy \"maxBy\" focuses on the first largest element in a List or a String , using another focuser as a key. Note: \"maxBy\" parses the next focuser non-greedily , i.e. \"maxBy focuser1.focuser2 == (maxBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxBy (focuser1.focuser2)\" Note: \"maxBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted. $ smh '<words>.maxBy len|get' \"Hello my name is Dani\" Hello Note: \"maxBy\" parses the next focuser non-greedily , i.e. \"maxBy focuser1.focuser2 == (maxBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxBy (focuser1.focuser2)\" min A shorthand for \"minBy id\" $ smh 'min|get' \"123\" 1 max A shorthand for \"maxBy id\" $ smh 'max|get' \"123\" 3 len (focuser) \"len\" focuses on the number of elements in a List or a String . $ smh 'words.len|get' \"hello\" 5 Note: \"len\" produces a Non-updatable focus. sum \"sum\" focuses on the sum of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.sum|get' \"1 2 3\" 6 Note: \"sum\" produces a Non-updatable focus. product \"product\" focuses on the product of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.product|get' \"1 2 3\" 6 Note: \"product\" produces a Non-updatable focus. average \"average\" focuses on the average of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.average 0|get' \"1 2 3\" 2 Note: \"average\" produces a Non-updatable focus. Note: \"average\" takes in a optional parameter which defines the default value when no elements that could be parsed as numbers are found. If no default value is given, it will be 0. add (focuser) \"add\" adds a number to a focus if it can be parsed as a number. $ smh 'words.add 1|get' \"1 2 3 4 5\" 2 3 4 5 6 Note: \"add\" produces a Non-updatable focus. sub (focuser) \"sub\" subtracts a number from a focus if it can be parsed as a number. $ smh 'words.sub 1|get' \"1 2 3 4 5\" 0 1 2 3 4 Note: \"sub\" produces a Non-updatable focus. mult (focuser) \"mult\" multiplies a number to a focus if it can be parsed as a number. $ smh 'words.mult 2|get' \"1 2 3 4 5\" 2 4 6 8 10 Note: \"mult\" produces a Non-updatable focus. div (focuser) \"div\" divides a focus by a number if the focus can be parsed as a number. $ smh 'words.div 2|get' \"1 2 3 4 5\" 0.5 1 1.5 2 2.5 Note: \"div\" produces a Non-updatable focus. pow (focuser) \"pow\" raises a focus to a power if the focus can be parsed as a number. $ smh 'words.pow 2|get' \"1 2 3 4 5\" 1 4 9 16 25 Note: \"pow\" produces a Non-updatable focus. abs (focuser) \"abs\" focuses on the absolute value of a focus if it can be parsed as a number. $ smh 'words.abs|get' \"-1 -2 -3 -4 -5\" 1 2 3 4 5 Note: \"abs\" produces a Non-updatable focus. sign (focuser) \"sign\" focuses on the sign of a focus if it can be parsed as a number. $ smh 'words.sign|get' \"-1 2 -3 0 -5\" -1 1 -1 0 -1 if \"if\" conditionally focuses on the same focus that it was given, if it passes a provided condition . Valid conditions satisfy the following non-formal grammar: <condition> := <condition_long> <condition> := one or more comparisons, or short comparisons, optionally in parenthesis, separated by \"&&\" or \"||\" <comparison> := [<quantor>] [<value>] <operator> [<quantor>] <value> <short_comparison> := [<quantor>] <focuser> <value> := <focusers> | <string_in_quotes> | <number> <operator> := \"=\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\" <quantor> := \"any\" | \"all\" <focuser> := any valid focuser <focusers> := one or more valid focusers separated by dot '.' $ smh 'words.if len>3|get' \"hello world my name is Dani\" hello world name Dani $ smh 'words.if >5|get' \"3 4 5 6 7\" 6 7 $ smh 'words.if abs=id && != 0|get' \"-1 -2 0 1 2\" 1 2 $ smh 'words if any=\"h\"|get' \"hello world my name is Dani\" hello $ smh 'words' if all isLower' \"hello world my name is Dani\" hello world my name is Logical focusers Logical focusers take in a String and produce a Non-updatable focus which is equal to either \"1\" or \"0\". They are used in short-form if conditions. Logical focusers include: \"isUpper\", \"isLower\", \"isDigit\", \"isAlpha\", \"isAlphaNum\", \"isSpace\", \"contains\", \"startsWith\", \"endsWith\". regex \"regex\" takes in a POSIX style regex and focuses on all substrings of a String focus that match it. $ smh 'words.regex \"[a-z]+\"|get' \"hello world my name is Dani\" hello world my name is ani filter \"filter\" works like \"if\", but instead of filtering the focus itself, it filters elements of a List or a String and focuses on a sub-list or a sub-string, that contains all the elements that passed. $ smh '<words>.filter len>3|get' \"hello world my name is Dani\" hello world name Dani to (focuser) \"to\" can convert a mapping list into a Non-updatable focuser. $ smh '<words>.to reverse|get' \"hello world my name is Dani\" Dani is name my world hello Note: For more information on mappings, visit Mapping documentation Action documentation get-tree \"get-tree\" displays the list of all focuses active at the end. $ smh 'words|get-tree' \"hello world my name is Dani\" [\"hello\",\"world\",\"my\",\"name\",\"is\",\"Dani\"] get \"get\" displays all strings found in all focuses active at the end, one string per line. $ smh 'words|get' \"hello world my name is Dani\" hello world my name is Dani over \"over\" takes in a list of mappings separated by \":\", applies them to the focuses and reconstructs the original string. $ smh 'words|over reverse' \"hello world my name is Dani\" olleh dlrow ym eman si inaD Note: For more information on mappings, visit Mapping documentation set \"set\" takes in a string and sets every string found in all focuses active at the end to that string. $ smh 'words|set \"hello\"' \"hello world my name is Dani\" hello hello hello hello hello hello Mapping documentation id (mapping) \"id\" is the simplest mapping possible, it returns the same focus that was given to it. $ smh 'id|over id' \"hello world\" hello world reverse \"reverse\" reverses a List or a String . $ smh '<words>|over reverse' \"hello world my name is Dani\" Dani is name my world hello len (mapping) \"len\" sets a String focus to its length. $ smh 'words|over len' \"hello world my name is Dani\" 5 5 2 4 2 4 map \"map\" takes in a mapping and applies it to every element of a List or a String . Note: \"map\" takes in a mapping non-greedily , i.e. \"map mapping1:mapping2\" == \"(map mapping1):mapping2\" To use multiple mappings, use parenthesis \"map (mapping1:mapping2)\" $ smh '<words>|over map len' \"hello world my name is Dani\" 5 5 2 4 2 4 append \"append\" takes in a string, number or a focuser and appends it to a String focus. $ smh 'words|over append \"!\"' \"hello world my name is Dani\" hello! world! my! name! is! Dani! $ smh 'words|over append len' \"hello world my name is Dani\" hello5 world5 my2 name4 is2 Dani4 prepend \"prepend\" takes in a string, number or a focuser and prepends it to a String focus. $ smh 'words|over prepend \"!\"' \"hello world my name is Dani\" !hello !world !my !name !is !Dani $ smh 'words|over prepend len' \"hello world my name is Dani\" 5hello 5world 2my 4name 2is 4Dani upper \"upper\" sets a String focus to its upper case. $ smh 'words|over upper' \"hello world my name is Dani\" HELLO WORLD MY NAME IS DANI lower \"lower\" sets a String focus to its lower case. $ smh 'words|over lower' \"HELLO WORLD MY NAME IS DANI\" hello world my name is dani add (mapping) \"add\" adds a number to a focus if it can be parsed as a number. $ smh 'words|over add 1' \"1 2 3\" 2 3 4 sub (mapping) \"sub\" subtracts a number from a focus if it can be parsed as a number. $ smh 'words|over sub 1' \"1 2 3\" 0 1 2 mult (mapping) \"mult\" multiplies a focus by a number if it can be parsed as a number. $ smh 'words|over mult 2' \"1 2 3\" 2 4 6 div (mapping) \"div\" divides a focus by a number if it can be parsed as a number. $ smh 'words|over div 2' \"1 2 3\" 0.5 1 1.5 pow (mapping) \"pow\" raises a focus to a power if the focus can be parsed as a number. $ smh 'words|over pow 2' \"1 2 3 4 5\" 1 4 9 16 25 abs (mapping) \"abs\" sets the focus to its absolute value if it can be parsed as a number. $ smh 'words|over abs' \"-1 -2 -3 -4 -5\" 1 2 3 4 5 sign (mapping) \"sign\" sets the focus to its sign if it can be parsed as a number. $ smh 'words|over sign' \"1 -2 3 0 -5\" 1 -1 1 0 -1 slice ({}) (mapping) \"slice\" sets a String focus to its part according to a python-like syntax. $ smh 'words|over {1:3}' \"hello\" el $ smh 'words|over {2:}' \"hello\" llo $ smh 'words|over {:-2}' \"hello\" hel $ smh 'words|over {:2,3:}' \"hello\" helo sortLexBy \"sortLexBy\" sorts a List or a String focus lexicographically using another focuser as a key. $ smh 'words|over sortLexBy id' \"hello my name is Dani\" ehllo my aemn is Dain sortLex \"sortLex\" is a shorthand for \"sortLexBy id\" sortBy \"sortBy\" sorts a List or a String focus using another focuser as a key. $ smh '<words>|over sortBy len' \"hello my name is Dani\" my is name Dani hello sort \"sort\" is a shorthand for \"sortBy id\" to (mapping) \"to\" produces a mapping from a focuser list that takes in a String focus and produces exactly one String focus. $ smh 'regex \"\\[[^]]*\\]\"|over to ({1:-1}.<words.regex \"[^,]*\">.sum)' \"[1, 2, 3] [4, 5]\" 6 9","title":"User Guide"},{"location":"user-guide/#_1","text":"","title":""},{"location":"user-guide/#overview","text":"","title":"Overview"},{"location":"user-guide/#heres-the-core-syntax-of-smh","text":"smh <command> [input] <command> is a string specifiyng what smh should do with the input string. If the input string is not given, smh gets input from stdin.","title":"Here's the core syntax of smh:"},{"location":"user-guide/#command-string","text":"The command string consists of two parts, separated by the pipe symbol \"|\"\" The first part is a list of focusers, separated by the dot symbol \".\" The second part is an action. The idea is that we use focusers to nail down on the part of the string that we want to access, and then the action that we want to perform on it. For example: smh 'words|get' \"hello world\" - 'words' focuser focuses on all words within the string, the get action prints them to the screen.","title":"&lt;command> string"},{"location":"user-guide/#how-do-focusers-work","text":"Each focuser in the focuser list can be thought of as a function that takes in a focus and returns a list of new focuses. Each focuser represents a focusing step. During each step, every active focus gets fed into the current focuser and all the new focuses that are produces go to the next step.","title":"How do focusers work?"},{"location":"user-guide/#what-is-a-focus","text":"Focuses can be devided into two groups: Updatable focuses - represent some part of the input string, these can be updated through actions, to get an updated input string. Non-updatable focuses - these represent read-only data, obtained from the input string, and thus can't be updated, only read. Focuses are further divided into two types: Strings - represent string data. Lists - represent lists of sub-focuses. For example the \"words\" focuser takes in a String focus and produces Updatable String focuses for each word in it. At the very start we have one active Updatable String focus which represents the whole input string. For the description of available focusers visit Focuser documentation","title":"What is a focus?"},{"location":"user-guide/#what-is-an-action","text":"Action is the part of the command string that goes after the pipe symbol. Actions can be used to display parts of input, or change them. For the description of available actions visit Action documentation","title":"What is an action?"},{"location":"user-guide/#focuser-documentation","text":"","title":"Focuser documentation"},{"location":"user-guide/#id-focuser","text":"\"id\" is the simplest focuser possible, it returns the same focus that was given to it. It can be useful if you want to focus on the whole input string. $ smh 'id|get' \"hello world\" hello world","title":"id (focuser)"},{"location":"user-guide/#each","text":"\"each\" focuses on each element of a List , or every character in a String . $ smh 'each|get' \"hello\" h e l l o","title":"each"},{"location":"user-guide/#words","text":"\"words\" focuses on each word within a String . $ smh 'words|get' \"hello world\" hello world","title":"words"},{"location":"user-guide/#lines","text":"\"lines\" focuses on every line within the input string. $ printf \"hello\\nworld\" | smh 'lines|get' hello world","title":"lines"},{"location":"user-guide/#ws","text":"\"ws\" focuses on consequetive strings of whitespace characters. $ smh '<ws>.len|get' \"a b c d e\" 4","title":"ws"},{"location":"user-guide/#cols","text":"\"cols\" focuses on every column within the input string. Columns are represented as Lists of words. $ smh '<cols>.[0]|get' \"hello my\\nname is Dani\" hello name","title":"cols"},{"location":"user-guide/#slice-focuser","text":"\"slice\" ({}) focuses on a part of a String or a List , using a python-like syntax. $ smh '{1:3}|get' \"hello\" el $ smh '{2:}|get' \"hello\" llo $ smh '{:-2}|get' \"hello\" hel $ smh '{:2,3:}|get' \"hello\" helo","title":"slice (focuser)"},{"location":"user-guide/#index-n","text":"\"index\" focuses on the nth element of a List or a String . $ smh '[1]|get' \"hello\" e","title":"index ([n])"},{"location":"user-guide/#sortedlexby","text":"\"sortedLexBy\" focuses on the lexicographically sorted version of a List or a String , using another focuser as a key. $ mh 'sortedLexBy id|get' \"hello\" ehllo Note: \"sortedLexBy\" parses the next focuser non-greedily , i.e. \"sortedLexBy focuser1.focuser2 == (sortedLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"sortedLexBy (focuser1.focuser2)\"","title":"sortedLexBy"},{"location":"user-guide/#sortedlex","text":"A shorthand for \"sortedLexBy id\"","title":"sortedLex"},{"location":"user-guide/#minlexby","text":"\"minLexBy\" focuses on the lexicographically smallest element in a List or a String , using another focuser as a key. $ smh '<words>.minLexBy id|get' \"hello my name is Dani\" Dani Note: \"minLexBy\" parses the next focuser non-greedily , i.e. \"minLexBy focuser1.focuser2 == (minLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"minLexBy (focuser1.focuser2)\"","title":"minLexBy"},{"location":"user-guide/#maxlexby","text":"\"maxLexBy\" focuses on the lexicographically largest element in a List or a String , using another focuser as a key. $ smh '<words>.maxLexBy id|get' \"hello my name is Dani\" name Note: \"maxLexBy\" parses the next focuser non-greedily , i.e. \"maxLexBy focuser1.focuser2 == (maxLexBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxLexBy (focuser1.focuser2)\"","title":"maxLexBy"},{"location":"user-guide/#minlex","text":"A shorthand for \"minLexBy id\"","title":"minLex"},{"location":"user-guide/#maxlex","text":"A shorthand for \"maxLexBy id\"","title":"maxLex"},{"location":"user-guide/#sortedby","text":"\"sortedBy\" focuses on the sorted version of a List or a String , using another focuser as a key. $ smh '<words>.sortedBy len|get' \"hello my name is Dani\" my is name Dani hello Note: \"sortedBy\" parses the next focuser non-greedily , i.e. \"sortedBy focuser1.focuser2 == (sortedBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"sortedBy (focuser1.focuser2)\" Note: \"sortedBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted.","title":"sortedBy"},{"location":"user-guide/#sorted","text":"A shorthand for \"sortedBy id\"","title":"sorted"},{"location":"user-guide/#minby","text":"\"minBy\" focuses on the first smallest element in a List or a String , using another focuser as a key. $ smh '<words>.minBy len|get' \"Hello my name is Dani\" my Note: \"minBy\" parses the next focuser non-greedily , i.e. \"minBy focuser1.focuser2 == (minBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"minBy (focuser1.focuser2)\" Note: \"minBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted.","title":"minBy"},{"location":"user-guide/#maxby","text":"\"maxBy\" focuses on the first largest element in a List or a String , using another focuser as a key. Note: \"maxBy\" parses the next focuser non-greedily , i.e. \"maxBy focuser1.focuser2 == (maxBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxBy (focuser1.focuser2)\" Note: \"maxBy\" compares focuses by trying to parse them as numbers and comparing those. Focuses which which cannot be parsed as numbers are not sorted. $ smh '<words>.maxBy len|get' \"Hello my name is Dani\" Hello Note: \"maxBy\" parses the next focuser non-greedily , i.e. \"maxBy focuser1.focuser2 == (maxBy focuser1).focuser2\" To use multiple focusers, use parenthesis \"maxBy (focuser1.focuser2)\"","title":"maxBy"},{"location":"user-guide/#min","text":"A shorthand for \"minBy id\" $ smh 'min|get' \"123\" 1","title":"min"},{"location":"user-guide/#max","text":"A shorthand for \"maxBy id\" $ smh 'max|get' \"123\" 3","title":"max"},{"location":"user-guide/#len-focuser","text":"\"len\" focuses on the number of elements in a List or a String . $ smh 'words.len|get' \"hello\" 5 Note: \"len\" produces a Non-updatable focus.","title":"len (focuser)"},{"location":"user-guide/#sum","text":"\"sum\" focuses on the sum of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.sum|get' \"1 2 3\" 6 Note: \"sum\" produces a Non-updatable focus.","title":"sum"},{"location":"user-guide/#product","text":"\"product\" focuses on the product of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.product|get' \"1 2 3\" 6 Note: \"product\" produces a Non-updatable focus.","title":"product"},{"location":"user-guide/#average","text":"\"average\" focuses on the average of all elements in a List or a String , that can be parsed as numbers. $ smh '<words>.average 0|get' \"1 2 3\" 2 Note: \"average\" produces a Non-updatable focus. Note: \"average\" takes in a optional parameter which defines the default value when no elements that could be parsed as numbers are found. If no default value is given, it will be 0.","title":"average"},{"location":"user-guide/#add-focuser","text":"\"add\" adds a number to a focus if it can be parsed as a number. $ smh 'words.add 1|get' \"1 2 3 4 5\" 2 3 4 5 6 Note: \"add\" produces a Non-updatable focus.","title":"add (focuser)"},{"location":"user-guide/#sub-focuser","text":"\"sub\" subtracts a number from a focus if it can be parsed as a number. $ smh 'words.sub 1|get' \"1 2 3 4 5\" 0 1 2 3 4 Note: \"sub\" produces a Non-updatable focus.","title":"sub (focuser)"},{"location":"user-guide/#mult-focuser","text":"\"mult\" multiplies a number to a focus if it can be parsed as a number. $ smh 'words.mult 2|get' \"1 2 3 4 5\" 2 4 6 8 10 Note: \"mult\" produces a Non-updatable focus.","title":"mult (focuser)"},{"location":"user-guide/#div-focuser","text":"\"div\" divides a focus by a number if the focus can be parsed as a number. $ smh 'words.div 2|get' \"1 2 3 4 5\" 0.5 1 1.5 2 2.5 Note: \"div\" produces a Non-updatable focus.","title":"div (focuser)"},{"location":"user-guide/#pow-focuser","text":"\"pow\" raises a focus to a power if the focus can be parsed as a number. $ smh 'words.pow 2|get' \"1 2 3 4 5\" 1 4 9 16 25 Note: \"pow\" produces a Non-updatable focus.","title":"pow (focuser)"},{"location":"user-guide/#abs-focuser","text":"\"abs\" focuses on the absolute value of a focus if it can be parsed as a number. $ smh 'words.abs|get' \"-1 -2 -3 -4 -5\" 1 2 3 4 5 Note: \"abs\" produces a Non-updatable focus.","title":"abs (focuser)"},{"location":"user-guide/#sign-focuser","text":"\"sign\" focuses on the sign of a focus if it can be parsed as a number. $ smh 'words.sign|get' \"-1 2 -3 0 -5\" -1 1 -1 0 -1","title":"sign (focuser)"},{"location":"user-guide/#if","text":"\"if\" conditionally focuses on the same focus that it was given, if it passes a provided condition . Valid conditions satisfy the following non-formal grammar: <condition> := <condition_long> <condition> := one or more comparisons, or short comparisons, optionally in parenthesis, separated by \"&&\" or \"||\" <comparison> := [<quantor>] [<value>] <operator> [<quantor>] <value> <short_comparison> := [<quantor>] <focuser> <value> := <focusers> | <string_in_quotes> | <number> <operator> := \"=\" | \"!=\" | \"<\" | \">\" | \"<=\" | \">=\" <quantor> := \"any\" | \"all\" <focuser> := any valid focuser <focusers> := one or more valid focusers separated by dot '.' $ smh 'words.if len>3|get' \"hello world my name is Dani\" hello world name Dani $ smh 'words.if >5|get' \"3 4 5 6 7\" 6 7 $ smh 'words.if abs=id && != 0|get' \"-1 -2 0 1 2\" 1 2 $ smh 'words if any=\"h\"|get' \"hello world my name is Dani\" hello $ smh 'words' if all isLower' \"hello world my name is Dani\" hello world my name is","title":"if"},{"location":"user-guide/#logical-focusers","text":"Logical focusers take in a String and produce a Non-updatable focus which is equal to either \"1\" or \"0\". They are used in short-form if conditions. Logical focusers include: \"isUpper\", \"isLower\", \"isDigit\", \"isAlpha\", \"isAlphaNum\", \"isSpace\", \"contains\", \"startsWith\", \"endsWith\".","title":"Logical focusers"},{"location":"user-guide/#regex","text":"\"regex\" takes in a POSIX style regex and focuses on all substrings of a String focus that match it. $ smh 'words.regex \"[a-z]+\"|get' \"hello world my name is Dani\" hello world my name is ani","title":"regex"},{"location":"user-guide/#filter","text":"\"filter\" works like \"if\", but instead of filtering the focus itself, it filters elements of a List or a String and focuses on a sub-list or a sub-string, that contains all the elements that passed. $ smh '<words>.filter len>3|get' \"hello world my name is Dani\" hello world name Dani","title":"filter"},{"location":"user-guide/#to-focuser","text":"\"to\" can convert a mapping list into a Non-updatable focuser. $ smh '<words>.to reverse|get' \"hello world my name is Dani\" Dani is name my world hello Note: For more information on mappings, visit Mapping documentation","title":"to (focuser)"},{"location":"user-guide/#action-documentation","text":"","title":"Action documentation"},{"location":"user-guide/#get-tree","text":"\"get-tree\" displays the list of all focuses active at the end. $ smh 'words|get-tree' \"hello world my name is Dani\" [\"hello\",\"world\",\"my\",\"name\",\"is\",\"Dani\"]","title":"get-tree"},{"location":"user-guide/#get","text":"\"get\" displays all strings found in all focuses active at the end, one string per line. $ smh 'words|get' \"hello world my name is Dani\" hello world my name is Dani","title":"get"},{"location":"user-guide/#over","text":"\"over\" takes in a list of mappings separated by \":\", applies them to the focuses and reconstructs the original string. $ smh 'words|over reverse' \"hello world my name is Dani\" olleh dlrow ym eman si inaD Note: For more information on mappings, visit Mapping documentation","title":"over"},{"location":"user-guide/#set","text":"\"set\" takes in a string and sets every string found in all focuses active at the end to that string. $ smh 'words|set \"hello\"' \"hello world my name is Dani\" hello hello hello hello hello hello","title":"set"},{"location":"user-guide/#mapping-documentation","text":"","title":"Mapping documentation"},{"location":"user-guide/#id-mapping","text":"\"id\" is the simplest mapping possible, it returns the same focus that was given to it. $ smh 'id|over id' \"hello world\" hello world","title":"id (mapping)"},{"location":"user-guide/#reverse","text":"\"reverse\" reverses a List or a String . $ smh '<words>|over reverse' \"hello world my name is Dani\" Dani is name my world hello","title":"reverse"},{"location":"user-guide/#len-mapping","text":"\"len\" sets a String focus to its length. $ smh 'words|over len' \"hello world my name is Dani\" 5 5 2 4 2 4","title":"len (mapping)"},{"location":"user-guide/#map","text":"\"map\" takes in a mapping and applies it to every element of a List or a String . Note: \"map\" takes in a mapping non-greedily , i.e. \"map mapping1:mapping2\" == \"(map mapping1):mapping2\" To use multiple mappings, use parenthesis \"map (mapping1:mapping2)\" $ smh '<words>|over map len' \"hello world my name is Dani\" 5 5 2 4 2 4","title":"map"},{"location":"user-guide/#append","text":"\"append\" takes in a string, number or a focuser and appends it to a String focus. $ smh 'words|over append \"!\"' \"hello world my name is Dani\" hello! world! my! name! is! Dani! $ smh 'words|over append len' \"hello world my name is Dani\" hello5 world5 my2 name4 is2 Dani4","title":"append"},{"location":"user-guide/#prepend","text":"\"prepend\" takes in a string, number or a focuser and prepends it to a String focus. $ smh 'words|over prepend \"!\"' \"hello world my name is Dani\" !hello !world !my !name !is !Dani $ smh 'words|over prepend len' \"hello world my name is Dani\" 5hello 5world 2my 4name 2is 4Dani","title":"prepend"},{"location":"user-guide/#upper","text":"\"upper\" sets a String focus to its upper case. $ smh 'words|over upper' \"hello world my name is Dani\" HELLO WORLD MY NAME IS DANI","title":"upper"},{"location":"user-guide/#lower","text":"\"lower\" sets a String focus to its lower case. $ smh 'words|over lower' \"HELLO WORLD MY NAME IS DANI\" hello world my name is dani","title":"lower"},{"location":"user-guide/#add-mapping","text":"\"add\" adds a number to a focus if it can be parsed as a number. $ smh 'words|over add 1' \"1 2 3\" 2 3 4","title":"add (mapping)"},{"location":"user-guide/#sub-mapping","text":"\"sub\" subtracts a number from a focus if it can be parsed as a number. $ smh 'words|over sub 1' \"1 2 3\" 0 1 2","title":"sub (mapping)"},{"location":"user-guide/#mult-mapping","text":"\"mult\" multiplies a focus by a number if it can be parsed as a number. $ smh 'words|over mult 2' \"1 2 3\" 2 4 6","title":"mult (mapping)"},{"location":"user-guide/#div-mapping","text":"\"div\" divides a focus by a number if it can be parsed as a number. $ smh 'words|over div 2' \"1 2 3\" 0.5 1 1.5","title":"div (mapping)"},{"location":"user-guide/#pow-mapping","text":"\"pow\" raises a focus to a power if the focus can be parsed as a number. $ smh 'words|over pow 2' \"1 2 3 4 5\" 1 4 9 16 25","title":"pow (mapping)"},{"location":"user-guide/#abs-mapping","text":"\"abs\" sets the focus to its absolute value if it can be parsed as a number. $ smh 'words|over abs' \"-1 -2 -3 -4 -5\" 1 2 3 4 5","title":"abs (mapping)"},{"location":"user-guide/#sign-mapping","text":"\"sign\" sets the focus to its sign if it can be parsed as a number. $ smh 'words|over sign' \"1 -2 3 0 -5\" 1 -1 1 0 -1","title":"sign (mapping)"},{"location":"user-guide/#slice-mapping","text":"\"slice\" sets a String focus to its part according to a python-like syntax. $ smh 'words|over {1:3}' \"hello\" el $ smh 'words|over {2:}' \"hello\" llo $ smh 'words|over {:-2}' \"hello\" hel $ smh 'words|over {:2,3:}' \"hello\" helo","title":"slice ({}) (mapping)"},{"location":"user-guide/#sortlexby","text":"\"sortLexBy\" sorts a List or a String focus lexicographically using another focuser as a key. $ smh 'words|over sortLexBy id' \"hello my name is Dani\" ehllo my aemn is Dain","title":"sortLexBy"},{"location":"user-guide/#sortlex","text":"\"sortLex\" is a shorthand for \"sortLexBy id\"","title":"sortLex"},{"location":"user-guide/#sortby","text":"\"sortBy\" sorts a List or a String focus using another focuser as a key. $ smh '<words>|over sortBy len' \"hello my name is Dani\" my is name Dani hello","title":"sortBy"},{"location":"user-guide/#sort","text":"\"sort\" is a shorthand for \"sortBy id\"","title":"sort"},{"location":"user-guide/#to-mapping","text":"\"to\" produces a mapping from a focuser list that takes in a String focus and produces exactly one String focus. $ smh 'regex \"\\[[^]]*\\]\"|over to ({1:-1}.<words.regex \"[^,]*\">.sum)' \"[1, 2, 3] [4, 5]\" 6 9","title":"to (mapping)"}]}